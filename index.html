<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IR T.V - Modern Layout</title>

    <script
    src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>
    
<style>
    /*
     * -----------------------------------------------------------------------------------------------------------------
     * Base Layout & Body Styles
     * -----------------------------------------------------------------------------------------------------------------
    */

    /* Base styles for the entire page */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* Prevent body scroll */
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font */
      color: #E0E0E0; /* Light text color for dark background */
    }

    /* Main background container using flexbox for layout */
    .background-layout {
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: row;
      background: #000;
      gap: 5px; /* Space between elements */
    }

    /*
     * -----------------------------------------------------------------------------------------------------------------
     * Main Content Layouts
     * -----------------------------------------------------------------------------------------------------------------
    */

    /* Main content area containing the chart and other panels */
    .main-layout {
      flex: 1; /* Takes up the remaining space */
      display: flex;
      flex-direction: row;
      position: relative; /* For positioning floating elements */
      background: #4c4c4c;
      border: 1px solid #666666;
    }

    /* Layout for the orderbook panel, initially hidden */
    .orderbook-layout {
      display: none;
      width: 30%; /* Occupies 30% of the main layout when visible */
      background: #4c4c4c;
      border: 1px solid #666666;
    }

    /* Layout for the trading chart */
    .chart-layout{
      flex: 1; /* Takes up the remaining space */
      display: flex;
      position: relative;
      background: #4c4c4c;
    }

    /*
     * -----------------------------------------------------------------------------------------------------------------
     * Floating UI Elements
     * -----------------------------------------------------------------------------------------------------------------
    */

    /* Container for floating buttons and controls */
    .floating-layout{
      position: absolute;
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: flex-start;
      top: 5px;
      left: 5px;
      right: 1px;
      z-index: 10; /* Ensures it appears on top of the chart */
      gap: 8px; /* Space between floating elements */
      overflow-x: auto; /* Allows horizontal scrolling */
      -ms-overflow-style: none; /* Hide scrollbar for IE/Edge */
      scrollbar-width: none; /* Hide scrollbar for Firefox */
      white-space: nowrap; /* Prevents wrapping */
      padding: 10px;
    }

    /* Hide scrollbar for Webkit browsers (Chrome, Safari) */
    .floating-layout:-webkit-scrollbar {
      display: none;
    }

    /* Floating countdown timer layout */
    .floating-countdown{
      position: absolute;
      top: 8px;
      right: 4.5px;
      z-index: 10; /* Ensures it's on top */
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: row;
      padding: 5px;
      backdrop-filter: blur(2px);
      background: #ffffff14;
      border: 1px solid #666666;
      border-radius: 10px;
      box-shadow: 0 0 5px black;
      gap: 5px;
      font-weight: bold;
      width: 60px;
      height: 10px;
    }

    /* Shared style for floating layout containers */
    .layout-floating {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: row;
      padding: 5px;
      backdrop-filter: blur(2px);
      background: #ffffff14;
      border: 1px solid #666666;
      border-radius: 10px;
      box-shadow: 0 0 5px black;
      gap: 5px;
      font-weight: bold;
    }

    /* Style for buttons within floating layouts */
    .button-floating {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 20px;
      width: 60px;
      background-color: #383838;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4);
      border: 1px solid #555555;
      border-radius: 15px;
      font-size: 12px;
      transition: all 0.2s ease-in-out;
    }

    /* Click effect for floating buttons */
    .button-floating:active {
      transform: translateY(2px);
      box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.5);
    }

    /*
     * -----------------------------------------------------------------------------------------------------------------
     * Specific Element Styles & States
     * -----------------------------------------------------------------------------------------------------------------
    */

    /* Layout for timeframe buttons, initially hidden */
    #timefreame-layout {
      display: none;
      width: fit-content;
    }

    /* Specific button for expanding indicators */
    #expand-indicator-button {
      width: fit-content;
      height: 20px;
    }

    /* Layout for indicator buttons, initially hidden */
    #indicator-btn-layout {
      display: none;
    }

    /* Style for selected buttons */
    .selected {
      background-color: #1e3a8a;
      color: #fff;
      box-shadow: 0 0 12px #3b82f6;
      transition: all 0.5s ease-in-out;
      border: 1px solid #3b82f6;
      fill: #fff;
      stroke: #fff;
    }

    /* Invert image color when the parent is selected */
    .selected img {
      filter: brightness(0) invert(1);
    }
    
    
.floating-data-layout {
  position: absolute;
  z-index: 20;
  display: none;
  padding: 5px;
  font-size: 12px;
  font-weight: bold;
  color: #fff;
  backdrop-filter: blur(2px);
  background: #ffffff14;
  border: 1px solid #666666;
  border-radius: 10px;
  pointer-events: none; /* so it won't block chart interaction */
  white-space: nowrap;
}


</style>
</head>
<body>
  <div class="background-layout">
    <div class="main-layout" id="main-layout">
      <div class="chart-layout" id="chart-view">
              <div class="floating-countdown"></div>
      </div>
      <div class="orderbook-layout" id="orderbook-layout"></div>
      <div class="floating-layout">
        <div class="layout-floating" id="chart-name-layout">
          <span>BTCUSDT</span>
          <div class="button-floating" id="preview-tf-btn">5M</div>
        </div>
        <div class="layout-floating" id="timefreame-layout">
          <div class="button-floating" id="1m">1M</div>
          <div class="button-floating" id="5m">5M</div>
          <div class="button-floating" id="15m">15M</div>
          <div class="button-floating" id="30m">30M</div>
          <div class="button-floating" id="1h">1H</div>
        </div>
        <div class="layout-floating" id="expand-indicator-button">
          <img src="https://cdn-icons-png.flaticon.com/512/271/271228.png"
          alt="expand-indi-btn" style="width:10px; height:10px;" />
        </div>
        <div class="layout-floating" id="indicator-btn-layout">
          <div class="button-floating" id="volume-btn">VOL</div>
          <div class="button-floating" id="cvd-btn">CDV</div>
          <div class="button-floating" id="rsi-btn">RSI</div>
          <div class="button-floating" id="orderbook-btn">OB</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Ensures the script runs after the entire HTML document is loaded
    document.addEventListener("DOMContentLoaded", () => {
        // Chart initialization and data fetching functions
        const chartView = document.getElementById("chart-view");
        const previewBtn = document.getElementById("preview-tf-btn");
        const volumeBtn = document.getElementById("volume-btn");

        // Select the floating countdown element
        const floatingCountdown = document.querySelector(".floating-countdown");

        // IST is UTC + 5 hours 30 minutes. 
        // We add 5.5 hours to the UTC timestamp to get the IST timestamp.
        const IST_OFFSET_MS = 5.5 * 60 * 60 * 1000; 

        // Properties for the Lightweight Charts instance
        const chartProperties = {
            width: chartView.offsetWidth,
            height: chartView.offsetHeight,
            layout: {
                background: {
                    color: 'rgba(0, 0, 0, 0)'
                },
                textColor: '#fff',
            },
                watermark: {
                visible: false,
            },
            grid: {
                vertLines: {
                    color: '#5656566e'
                },
                horzLines: {
                    color: '#5656566e'
                },
            },
            // Configuration for the time axis
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
                tickMarkFormatter: (time) => {
                    // Binance gives seconds â†’ convert to ms
                    const date = new Date(time * 1000);

                    // Format to IST using Intl
                    const formatter = new Intl.DateTimeFormat('en-IN', {
                        timeZone: 'Asia/Kolkata',
                        hour: 'numeric',
                        minute: 'numeric',
                        hour12: true,
                    });
                    return formatter.format(date);
                }
            },
            // Configuration for the crosshair tooltips
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
                horzLine: { visible: true, labelVisible: false },
                vertLine: {
                    visible: true,
                    labelVisible: true,
                    labelFormatter: (time) => {
                        const date = new Date(time * 1000);
                        return new Intl.DateTimeFormat('en-IN', {
                            timeZone: 'Asia/Kolkata',
                            year: 'numeric',
                            month: 'short', // e.g. Jan, Feb
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: true,
                        }).format(date);
                    }
                }
            },
            // âœ… fixes the bottom tooltip time as well (date + time)
            localization: {
                timeFormatter: (time) => {
                    const date = new Date(time * 1000);
                    return new Intl.DateTimeFormat('en-IN', {
                        timeZone: 'Asia/Kolkata',
                        year: 'numeric',
                        month: 'short',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: true,
                    }).format(date);
                }
            }
        };

        // Create the chart instance and add a candlestick series
        const chart = LightweightCharts.createChart(chartView, chartProperties);
        const candleSeries = chart.addCandlestickSeries({
            upColor: '#2ecc71',
            downColor: '#e74c3c',
            borderDownColor: '#e74c3c',
            borderUpColor: '#2ecc71',
            wickDownColor: '#e74c3c',
            wickUpColor: '#2ecc71',
        });

        // Add a new volume series to the chart
        const volumeSeries = chart.addHistogramSeries({
            color: '#383838', // A neutral color for volume bars
            priceFormat: {
                type: 'volume',
            },
            priceScaleId: '', // Set an empty price scale ID to make it an overlay
        });
        // Create a floating element for volume display
// Create floating element for volume
const floatingVolume = document.createElement("div");
floatingVolume.className = "floating-data-layout";
floatingVolume.textContent = "VOL: 0";
document.querySelector(".chart-layout").appendChild(floatingVolume);

chart.subscribeCrosshairMove(param => {
    if (!param || !param.time || !param.point || !param.seriesData) {
        floatingVolume.style.display = "none"; 
        return;
    }

    const volData = param.seriesData.get(volumeSeries);
    if (volData) {
        floatingVolume.style.display = "block";
        floatingVolume.textContent = `VOL: ${volData.value}`;

        // Move box near crosshair
        const chartElement = document.querySelector(".chart-layout");
        const chartRect = chartElement.getBoundingClientRect();

        floatingVolume.style.left = (param.point.x + 10) + "px"; // offset to the right
        floatingVolume.style.top = (param.point.y - 20) + "px";  // offset above
    }
});
        
        // Ensure volume series is initially hidden
        volumeSeries.applyOptions({
            priceScaleId: 'volume_scale',
            visible: false,
        });

        // Set up separate price scales for price and volume to prevent overlap
        chart.priceScale('volume_scale').applyOptions({
            scaleMargins: {
                top: 0.7, // 70% of the space is for the price chart
                bottom: 0, // 30% of the space is for the volume chart
            },
        });
        
        // Variables to manage WebSocket connections and countdown timers
        let currentWebSocket;
        let countdownInterval;
        let currentIntervalMs;

        // Mapping timeframes to milliseconds for easier calculation
        const intervalToMs = {
            "1m": 60 * 1000,
            "5m": 5 * 60 * 1000,
            "15m": 15 * 60 * 1000,
            "30m": 30 * 60 * 1000,
            "1h": 60 * 60 * 1000,
        };

        /**
         * Fetches historical candlestick data from the Binance API.
         * @param {string} interval The timeframe interval (e.g., "1m", "5m").
         */
        async function fetchHistoricalData(interval) {
            const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${interval}&limit=1000`);
            const data = await response.json();
            const formattedCandleData = data.map(d => ({
                time: d[0] / 1000,
                open: parseFloat(d[1]),
                high: parseFloat(d[2]),
                low: parseFloat(d[3]),
                close: parseFloat(d[4])
            }));
            const formattedVolumeData = data.map(d => ({
                time: d[0] / 1000,
                value: parseFloat(d[5]), // Volume is at index 5
                color: parseFloat(d[4]) >= parseFloat(d[1]) ? '#26a69a' : '#ef5350' // Color based on candle direction
            }));
            
            candleSeries.setData(formattedCandleData);
            volumeSeries.setData(formattedVolumeData);
        }
        function animateCandleUpdate(series, newData, duration = 300, steps = 10) {
    const lastBar = series._lastBar;
    if (!lastBar) {
        series.update(newData);
        series._lastBar = newData;
        return;
    }

    let step = 0;
    const interval = duration / steps;

    const animate = setInterval(() => {
        step++;
        const progress = step / steps;

        const interpolated = {
            time: newData.time,
            open: lastBar.open + (newData.open - lastBar.open) * progress,
            high: lastBar.high + (newData.high - lastBar.high) * progress,
            low: lastBar.low + (newData.low - lastBar.low) * progress,
            close: lastBar.close + (newData.close - lastBar.close) * progress,
        };

        series.update(interpolated);

        if (step >= steps) {
            clearInterval(animate);
            series._lastBar = newData;
        }
    }, interval);
}

        /**
         * Starts a live WebSocket data stream for a given interval.
         * Closes any existing connection before starting a new one.
         * @param {string} interval The timeframe interval.
         */
        function startLiveStream(interval) {
            // Close any active WebSocket connection before starting a new one
            if (currentWebSocket) {
                currentWebSocket.close();
            }
            
            // Start the countdown immediately based on a client-side estimate
            updateCountdown(getEstimatedEndTime(interval), false, true);

            // Create a new WebSocket connection to the Binance stream
            const ws = new WebSocket(`wss://stream.binance.com:9443/ws/btcusdt@kline_${interval}`);
            currentWebSocket = ws;

            // Handle incoming messages from the WebSocket
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data).k;
                const update = {
                    time: data.t / 1000,
                    open: parseFloat(data.o),
                    high: parseFloat(data.h),
                    low: parseFloat(data.l),
                    close: parseFloat(data.c)
                };
                
                const volumeUpdate = {
                    time: data.t / 1000,
                    value: parseFloat(data.v),
                    color: parseFloat(data.c) >= parseFloat(data.o) ? '#26a69a' : '#ef5350'
                }

                // Update the chart with the new candle data
                // Smooth animated update for candles
animateCandleUpdate(candleSeries, update, 400, 12);

// Volume can stay instant, or we can animate too later
volumeSeries.update(volumeUpdate);

                // Sync the countdown with the precise server time from the WebSocket data
                // ðŸ’¡ FIX: Use the IST offset for the countdown calculation.
                updateCountdown(data.T + IST_OFFSET_MS, data.x, false);
            };
        }

        // Function to update the countdown timer
        function updateCountdown(candleCloseTime, isCandleClosed, isEstimated) {
            // Clear the previous interval if it exists
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            if (isCandleClosed) {
                floatingCountdown.textContent = "00:00";
                return;
            }

            // Set a new interval to update the countdown every second
            countdownInterval = setInterval(() => {
                const now = Date.now() + IST_OFFSET_MS; // Use IST for the countdown
                const timeRemaining = candleCloseTime - now;

                if (timeRemaining <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    floatingCountdown.textContent = "00:00";
                    return;
                }

                const minutes = Math.floor(timeRemaining / 60000);
                const seconds = Math.floor((timeRemaining % 60000) / 1000);

                const formattedMinutes = minutes < 10 ? `0${minutes}` : minutes;
                const formattedSeconds = seconds < 10 ? `0${seconds}` : seconds;

                floatingCountdown.textContent = `${formattedMinutes}:${formattedSeconds}`;
            }, 1000);
        }

        // Function to calculate the estimated end time for a candle
        function getEstimatedEndTime(interval) {
            // Use IST for the countdown
            const now = Date.now() + IST_OFFSET_MS;
            const intervalToMs = {
                "1m": 60 * 1000,
                "5m": 5 * 60 * 1000,
                "15m": 15 * 60 * 1000,
                "30m": 30 * 60 * 1000,
                "1h": 60 * 60 * 1000,
            };
            const intervalMs = intervalToMs[interval];
            const roundedTime = Math.floor(now / intervalMs) * intervalMs;
            return roundedTime + intervalMs;
        }

        /**
         * Updates the chart with a new timeframe.
         * Fetches historical data and starts a new live stream.
         * @param {string} interval The timeframe interval (e.g., "1m", "15m", "1h").
         */
        async function updateChart(interval) {
            // Clear the countdown timer when changing the timeframe
            clearInterval(countdownInterval);
            countdownInterval = null;
            floatingCountdown.textContent = "00:00"; // Reset the display

            // Fetch historical data and start the live stream
            await fetchHistoricalData(interval);
            startLiveStream(interval);
        }

        // Timeframe buttons logic
        const tfButtons = ["1m", "5m", "15m", "30m", "1h"];
        const defaultId = "5m";
        const defaultBtn = document.getElementById(defaultId);

        // Set initial state for the default timeframe
        if (defaultBtn) {
            defaultBtn.classList.add("selected");
            previewBtn.textContent = defaultBtn.textContent.toUpperCase();
            updateChart(defaultId);
        }

        // Add event listeners to all timeframe buttons
        tfButtons.forEach(id => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.addEventListener("click", () => {
                    // Remove 'selected' class from all other buttons
                    tfButtons.forEach(otherId => {
                        document.getElementById(otherId)?.classList.remove("selected");
                    });
                    // Add 'selected' class to the clicked button
                    btn.classList.add("selected");

                    // Update the preview button text and the chart
                    previewBtn.textContent = btn.textContent.toUpperCase();
                    updateChart(id);
                });
            }
        });

        // Toggling layout buttons logic
        // Map button IDs to the layout IDs they control
        const mappings = {
            "preview-tf-btn": "timefreame-layout",
            "expand-indicator-button": "indicator-btn-layout",
            "orderbook-btn": "orderbook-layout",
          
        };

        // Add click listeners to all toggle buttons
        Object.keys(mappings).forEach(clickId => {
            const clickElem = document.getElementById(clickId);
            let layoutElem = document.getElementById(mappings[clickId]);

            if (clickElem && layoutElem) {
                clickElem.addEventListener("click", () => {
                    const isActive = clickElem.classList.contains("selected");

                    if (isActive) {
                        // Deactivate the button and hide the layout
                        clickElem.classList.remove("selected");
                        layoutElem.style.display = "none";
                        if (clickId === "orderbook-btn") {
                            chartView.style.width = ""; // Reset width for orderbook
                        }
                    } else {
                        // Activate the button and show the layout
                        clickElem.classList.add("selected");
                        layoutElem.style.display = "flex";
                        if (clickId === "orderbook-btn") {
                            chartView.style.width = "70%"; // Set width for orderbook
                        }
                    }

                    // Resize the chart to fit the new layout
                    chart.applyOptions({
                        width: chartView.offsetWidth,
                        height: chartView.offsetHeight
                    });
                });
            }
        });

        // Add event listener for the volume button
        if (volumeBtn) {
            volumeBtn.addEventListener("click", () => {
                const isVolumeVisible = volumeBtn.classList.contains("selected");
                
                if (isVolumeVisible) {
                    volumeBtn.classList.remove("selected");
                    volumeSeries.applyOptions({ visible: false });
                } else {
                    volumeBtn.classList.add("selected");
                    volumeSeries.applyOptions({ visible: true });
                }
            });
        }
        
        // Handle window resize to resize the chart
        window.addEventListener('resize', () => {
            chart.applyOptions({
                width: chartView.offsetWidth,
                height: chartView.offsetHeight
            });
        });
    });
  </script>

</body>
</html>
